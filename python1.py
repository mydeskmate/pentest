# 一.一行代码实现1--100之和
#利用sum()函数求和

# #方法1:
# print(sum(list(range(1,101))))

# #方法2:
# total = 0
# for i in range(1,101):
#     total += i
# print(total)


# 二. python2和python3的range（100）的区别

# python2返回列表，python3返回迭代器，节约内存



# 三. 列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]

# list1 = [1,2,3,4,5]
# def pingfang(x):
#     return x**2
# res = map(pingfang,list1)

# res = [i for i in res if i > 10]
# print(res)


# 四. python中生成随机整数、随机小数、0--1之间小数方法
# import random
# import numpy
# print(random.randint(1,10))

# print(numpy.random.randn(5))

# print(random.random())

# 16、<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的
# import re
# content = '<div class="nam">中国</div>'
# res = re.findall(r'<div class=".*">(.*)</div>',content)
# print(res)

# 五. python中断言方法举例

# assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错
# a = 3
# assert(a > 1)
# print('断言成功,程序向下执行')


# a = 4
# assert(a > 7)
# print('断言失败,程序报错')

# 六. 数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句
# select distinct name  from student

# 七. 10个Linux常用命令
#  ls cmd pwd cd ps kill grep awk find passwd vim cat touch rm less echo tree

# 八. python2和python3区别？列举5个

# 1、Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')

# Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'

# 2、python2 range(1,10)返回列表，python3中返回迭代器，节约内存

# 3、python2中使用ascii编码，python中使用utf-8编码

# 4、python2中unicode表示字符串序列，str表示字节序列

#       python3中str表示字符串序列，byte表示字节序列

# 5、python2中为正常显示中文，引入coding声明，python3中不需要

# 6、python2中是raw_input()函数，python3中是input()函数


# 九. 列出python中可变数据类型和不可变数据类型，并简述原理
# 不可变数据类型：数值型、字符串型string和元组tuple
# 可变数据类型：列表list和字典dict；

# 十. s = "ajldjlajfdljfddd"，去重并从小到大排序输出"adfjl"
# s =  "ajldjlajfdljfddd"
# s = set(s)
# s = list(s)
# s.sort(reverse=False)
# s = "".join(s)
# print(s)


# 十. 用lambda函数实现两个数相乘

# f = lambda x,y:x * y
# print(f(2,3))

# l1 = [1,2,3]
# m = map(lambda x:x**2,l1)
# print(list(m))

# 十一. 字典根据键从小到大排序

# dict={"name":"zs","age":18,"city":"深圳","tel":"1362626627"}
# list = sorted(dict.items(),key= lambda x: x[0])
# new_dict = {}
# for i in list:
#     new_dict[i[0]] = i[1]
# print(new_dict)

# 十二. 利用collections库的Counter方法统计字符串每个单词出现的次数"kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
# from collections import Counter
# s = "kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
# print(Counter(s))

# 十三. 字符串a = "not 404 found 张三 99 深圳"，每个词中间是空格，用正则过滤掉英文和数字，最终输出"张三  深圳"
# import re
# a = "not 404 found 张三 99 深圳"
# res = re.findall('[^(" ",a-z,A-Z,0-9)]+',a)
# print(" ".join(res))

# 十四. filter方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# def is_odd(x):
#     return x % 2 == 1

# f = filter(is_odd,a)
# print(list(f))

# 十五. 列表推导式求列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# res = [x for x in a if x % 2 ==1]
# print(res)

# 十六. 两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,5,6,7,8,9]
# x = [1,5,7,9]
# y = [2,2,6,8]
# x.extend(y)
# x.sort()
# print(x)

# 十七. log日志中，我们需要用时间戳记录error,warning等的发生时间，请用datetime模块打印当前时间戳 “2018-04-01 11:38:54”
# import datetime
# now = datetime.datetime.now()
# t = now.strftime('%Y-%m-%d %H:%M:%S')
# w = now.isoweekday()
# print('%s 星期: %s' % (t,w))

# 十八. 数据库优化查询方法

# 外键、索引、联合查询、选择特定字段等等


# 十九. 写一段自定义异常代码

# def fn():
#     try:
#         for i in range(1,10):
#             if i > 4:
#                 raise Exception("大于4了,坏了")
#             print(i)
#     except Exception as e:
#         print(e)

# fn()

# 二十. 正则表达式匹配中，（.*）和（.*?）匹配区别？

# （.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配

# （.*?）是非贪婪匹配，会把满足正则的尽可能少匹配

# 二十一. 简述Django的orm

# ORM，全拼Object-Relation Mapping，意为对象-关系映射

# 实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可

# 二十二. [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]
# list1 = [[1,2],[3,4],[5,6]]
# res = [j for i in list1 for j in i]
# print(res)

# 二十三. x="abc",y="def",z=["d","e","f"],分别求出x.join(y)和x.join(z)返回的结果

# join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致，有没有突然感觉字符串的常见操作都不会玩了

# 顺便建议大家学下os.path.join()方法，拼接路径经常用到，也用到了join,和字符串操作中的join有什么区别，该问题大家可以查阅相关文档，后期会有答案

# 二十四. python中交换两个数值
# a,b = 3,4
# print(a,b)
# b,a = a,b
# print(a,b)

# 二十五. zip()函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。

# zip()参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不同时，zip能自动以最短序列长度为准进行截取，获得元组。
# x = [1,2,3]
# y = ["a","b","c"]
# z = zip(x,y)
# print(list(z))


# 二十六. a="张明 98分"，用re.sub，将98替换为100
# a="张明 98分"
# import re
# b = re.sub('[0-9]+','100',a)
# print(b)

# 二十七. 写5条常用sql语句

# show databases;

# show tables;

# desc 表名;

# select * from 表名;

# delete from 表名 where id=5;

# update students set gender=0,hometown="北京" where id=5

# 二十八. a="hello"和b="你好"编码成bytes类型
# a="hello"
# print(bytes(a,encoding="utf-8"))
# print(b'hello')
# b="你好"
# print(b.encode(encoding="utf-8"))

# 二十九.提高python运行效率的方法

# 1、使用生成器，因为可以节约大量内存

# 2、循环代码优化，避免过多重复代码的执行

# 3、核心模块用Cython  PyPy等，提高效率

# 4、多进程、多线程、协程

# 5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率


# 三十. 遇到bug如何处理

# 1、细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log

# 2、如果涉及一些第三方框架，会去查官方文档或者一些技术博客。

# 3、对于bug的管理与归类总结，一般测试将测试出的bug用teambin等bug管理工具进行记录，然后我们会一条一条进行修改，修改的过程也是理解业务逻辑和提高自己编程逻辑缜密性的方法，我也都会收藏做一些笔记记录。

# 4、导包问题、城市定位多音字造成的显示错误问题.


# 三十一. 51、正则匹配，匹配日期2018-03-20
# import re
# url='https://sycm.taobao.com/bda/tradinganaly/overview/get_summary.json?dateRange=2018-03-20%7C2018-03-20&dateType=recent1&device=1&token=ff25b109b&_=1521595613462'
# res = re.findall(r'[0-9]{4}-[0-9]{2}-[0-9]{2}',url)
# print(res)

# 三十二. list=[2,3,5,4,9,6]，从小到大排序，不许用sort，输出[2,3,4,5,6,9]
# list=[2,3,5,4,9,6]
# res = sorted(list)
# print(res)


# 三十三. 53、写一个单例模式

# 因为创建对象时__new__方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个

# class Single(object):
#     __instance = None

#     def __init__(self,name,age):
#         self.name = name
#         self.age = age

#     def __new__(cls,name,age):
#         if not cls.__instance:
#             cls.__instance = object.__new__(cls)
#         return cls.__instance


# a = Single('han',20)
# b = Single('wang',30)

# print(id(a))
# print(id(b))

# 三十四 保留两位小数
# a = "%.03f"%1.33335
# print(a,type(a))

# b = round(float(a),2)
# print(b)

# 三十五  可变数据特性

# def fn(k,v,dic={}):
#     dic[k] = v
#     print(dic,id(dic))

# fn('one',1)
# fn('two',2)
# fn('ddd',3,{})

# 三十六. 分别从前端、后端、数据库阐述web项目的性能优化

# 该题目网上有很多方法，我不想截图网上的长串文字，看的头疼，按我自己的理解说几点

# 前端优化：

# 1、减少http请求、例如制作精灵图

# 2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差



# 后端优化：

# 1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。

# 2、异步方式，如果有耗时操作，可以采用异步，比如celery

# 3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况



# 数据库优化：

# 1、如有条件，数据可以存放于redis，读取速度快

# 2、建立索引、外键等


# 三十七.  python中copy和deepcopy区别
# 1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同。
# 2、复制的值是可变对象（列表和字典）

# 浅拷贝copy有两种情况：

# 第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。

# 第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。

# 深拷贝deepcopy：完全复制独立，包括内层列表和字典

# import copy
# list1 = [1,2,3,4]
# x = list1
# print(x,id(x))
# a = copy.copy(list1)
# b = copy.deepcopy(list1)
# print(list1,id(list1))
# print(a,id((a)))
# print(b,id(b))

# x[1] = 10
# print('x',x)
# print('a',a)
# print('b',b)
# print('list1',list1)

# import copy
# list1 = [1,2,[3,4]]
# x = list1
# print(x,id(x))
# a = copy.copy(list1)
# b = copy.deepcopy(list1)
# print(list1,id(list1))
# print(a,id((a)))
# print(b,id(b))

# x[1] = 10
# print('x',x)
# print('a',a)
# print('b',b)
# print('list1',list1)

# import copy
# list1 = [1,2,[3,4]]
# x = list1
# print(x,id(x))
# a = copy.copy(list1)
# b = copy.deepcopy(list1)
# print(list1,id(list1))
# print(a,id((a)))
# print(b,id(b))

# x[2][0] = 10
# print('list1',list1)
# print('x',x)
# print('a',a)
# print('b',b)

# 三十八  列表嵌套字典的排序，分别根据年龄和姓名排序

# foo = [{"name":"zs","age":19},{"name":"ll","age":54},{"name":"wa","age":17},{"name":"df","age":23}]
# res1 = sorted(foo,key=lambda x: x['name'])
# print(res1)

# res2 = sorted(foo,key=lambda x: x['age'],reverse=True)
# print(res2)


# view   77个


# 三十八. 根据键对字典排序（方法一，zip函数）
# dic = {'name':'zs',"sex":"man","city":"bj"}
# foo = zip(dic.keys(),dic.values())
# foo = list(foo)
# b = sorted(foo,key=lambda x: x[0])
# print('根据键排序',b)
# new_dic = {i[0]:i[1] for i in b}
# print("字典推导式构造字典",new_dic)

# 三十九. 根据键对字典排序（方法二,不用zip)
# 有没有发现dic.items和zip(dic.keys(),dic.values())都是为了构造列表嵌套字典的结构，方便后面用sorted()构造排序规则
# dic = {'name':'zs',"sex":"man","city":"bj"}
# b = sorted(dic.items(),key=lambda x: x[0])
# print('根据键排序',b)
# new_dic = {i[0]:i[1] for i in b}
# print("字典推导式构造字典",new_dic)


# 四十. 最后出一道检验题目，根据字符串长度排序，看排序是否灵活运用
# s = ["ab","abc","a","djdj"]
# # 不修改自身
# b = sorted(s, key=lambda x: len(x))
# print(b,s)

# # 修改自身
# s.sort(key=len)
# print(s)


# 四十一. s="info:xiaoZhang 33 shandong",用正则切分字符串输出['info', 'xiaoZhang', '33', 'shandong']
# import re
# s="info:xiaoZhang 33 shandong"
# # res = re.split('[: ]',s)
# res = re.split(':| ',s)
# print(res)


# 四十二. 正则匹配以163.com结尾的邮箱
# import re
# email_list = ['xiaowang@163.com','xiaowang@163.comhehe','.com.xiaowang.com']
# for email in email_list:
#     ret = re.match("[\w]{4,20}@163\.com$",email)
#     if ret:
#         print("%s 是符合规定的邮件地址,匹配的结果是: %s" % (email,ret.group()))
#     else:
#         print("%s 不符合要求" % email)

# 四十三 递归求和
# def get_sum(num):
#     if num >= 1:
#         res = num + get_sum(num - 1)
#     else:
#         res = 0
#     return res

# res = get_sum(10)
# print(res)


# 四十四. MyISAM 与 InnoDB 区别：

# 1、InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高

# 级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM

# 就不可以了；

# 2、MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到

# 安全性较高的应用；

# 3、InnoDB 支持外键，MyISAM 不支持；

# 4、对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM

# 表中可以和其他字段一起建立联合索引；

# 5、清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重

# 建表；

# 四十五 正则匹配不是以4和7结尾的手机号
# import re
# tels = ["13100001234","18912344321","10086","18800007777"]
# for tel in tels:
#     ret = re.match('1\d{9}[1-3,5-6,8-9]',tel)
#     if ret:
#         print("想要的结果:",ret.group())
#     else:
#         print("不想要的结果:",tel)

# 四十六. 列举3条以上PEP8编码规范

# 1、顶级定义之间空两行，比如函数或者类定义。

# 2、方法定义、类定义与第一个方法之间，都应该空一行

# 3、三引号进行注释

# 4、使用Pycharm、Eclipse一般使用4个空格来缩进代码

# 四十七 正则匹配中文
# import re
# title = '你好,hello,世界'
# patt = re.compile(r'[\u4e00-\u9f5a]+')
# res = patt.findall(title)
# print(res)

# 四十八 生成0-100的随机数
# import random
# n1 = random.random() * 100
# print(n1)

# n2 = random.randint(1,100)
# print(n2)

# n3 = random.choice(range(1,101))
# print(n3)


# 四十八. 区分深拷贝和浅拷贝,赋值?
# 1、赋值：简单地拷贝对象的引用，两个对象的id相同。

# 2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。

# 3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。

# 浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。


# 四十九 闭包
# def num2(n):
#     i = 1
#     def num_in():
#         nonlocal i
#         i = i + n
#         print(i)
#     return num_in

# i = 0
# start = num2(3)
# while i<5:
#     start()
#     i += 1

# 五十 匿名函数
# from functools import reduce
# def num(x, y):
#     return x + y
# print(reduce(num, [1, 2, 3, 4]))

# res = reduce(lambda x,y: x + y,[1,2,3,4])
# print(res)

# print(list(filter(lambda x: x%2==0,range(10))))


# 五十一 多进程 多线程

# from multiprocessing import Process
# from threading import Thread
# import os,time
# def work():
#     res=0
#     for i in range(100000000):
#         res*=i

# if __name__ == "__main__":
#     l = []
#     start = time.time()
#     for i in range(4):
#         p = Process(target=work)
#         # p = Thread(target=work)
#         l.append(p)
#         p.start()
#     for p in l:
#         p.join()
#     stop = time.time()
#     print("run time is %s" % (stop-start))


# import threading
# import os
# from time import sleep

# def sorry(i):
#     sleep(5)
#     print('say sorry  {}'.format(i))


# if __name__ == '__main__':
#     for i in range(1,10):
#         t = threading.Thread(target=sorry, args=(i,))
#         t.start()


# 五十二 协程
# def custumer():
#     r = ''
#     while True:
#         n = yield r  # 接受send的值  返出yield的值
#         if not n:
#             return
#         print('custer {}'.format(n))
#         r = 'done'

# def produce(c):
#     c.__next__()
#     n = 0
#     while n < 5:
#         n += 1
#         print('produce {}'.format(n))
#         r = c.send(n)
#         print('custer return {}'.format(r))
#     c.close()

# c = custumer()
# produce(c)

 # 协程
# import gevent
# import time


# def foo():
#     print("running in foo")

#     gevent.sleep(2)

#     print("switch to foo again")


# def bar():
#     print("switch to bar")

#     gevent.sleep(5)

#     print("switch to bar again")


# start = time.time()

# gevent.joinall(

#     [gevent.spawn(foo),

#      gevent.spawn(bar)]

# )

# print(time.time() - start)

# 五十三 Fibonacci数列
# def  fab(n):
#     a, b = 0, 1
#     while n:
#         yield b
#         a, b = b,a+b
#         n -= 1

# print(list(fab(10)))


# def fab(n):
#     if n > 2:
#         res = fab(n-1) + fab(n-2)
#     else:
#         res = 1
#     return res

# l = []
# for i in range(1, 11):
#     l.append(fab(i))
# print(l)

# 五十四  函数赋值   难点
# 函数中 默认参数为可变数据时， 只初始化一次
# def f(x, l=[]):
#     for i in range(x):
#         l.append(i*i)
#     print(l)

# f(2) # [0, 1]
# f(3,[3,2,1]) # [3, 2, 1, 0, 1, 4]  # 自己单独开辟
# f(3) # [0, 1, 0, 1, 4]  # 和f(2)共用

#  设计模式
#  五十五 单例

# 单例---类方法方式

# class Single():
#     def __init__(self, name):
#         self.name = name
#     @classmethod
#     def instance(cls, *args, **kwargs):
#         if not hasattr(Single, "_instance"):
#             Single._instance = Single(*args, **kwargs)
#         return Single._instance
# s1 = Single.instance('Gage')
# s2 = Single.instance()
# print(s1)
# print(s2)
# 单例---new方式
# class Single(object):
#     __isstance = None
#     __first_init = False
#     def __new__(cls, *args, **kwargs):
#         if not cls.__isstance:
#             cls.__isstance = object.__new__(cls)
#         return cls.__isstance
#     def __init__(self, name):
#         if not self.__first_init:
#             self.name = name
#             Singleton.__first_init = True
# a = Single('a')
# b = Single('b')
# print(id(a))
# print(id(b))


# 五十六 工厂模式
# # 首先定义一个抽象基类
# class CarStore(object):

#     # 定义生产汽车的方法
#     def createcar(self, name):
#         pass

#     # 根据类型去生产车
#     def order(self, name):
#         self.car = self.createcar(name)
#         self.car.move()


# # 定义4s店  实现抽象类
# class AoDiCarStore(CarStore):

#     def createcar(self, name):
#         self.factory = CarFactory()
#         return self.factory.createcar(name)


# # 创建一个车
# class AoDi():
#     def move(self):
#         print('移动')
# # 定义一个工厂
# class CarFactory():
#     def createcar(self, name):
#         self.name = name
#         if self.name == 'AoDi':
#             self.car = AoDi()
#         return self.car
# aodi = AoDiCarStore()
# aodi.order('AoDi')


# 五十七  二分法
# mylist = [1,3,5,7,9]  找到3

# def search(mylist,item):
#     low = 0
#     high = len(mylist) -1
#     while True:
#         mid = (low + high) //2
#         if mylist[mid] > item:
#             high = mid - 1
#         elif mylist[mid] < item:
#             low = mid + 1
#         else:
#             return mid


# mylist = [1,3,5,7,9]
# res = search(mylist,9)
# print(res)

# 五十八 单引号，双引号，三引号的区别
# 分别阐述3种引号用的场景和区别
# 1),单引号和双引号主要用来表示字符串
# 比如:
# 单引号:'python'
# 双引号:"python"
# 2).三引号
# 三单引号:'''python ''',也可以表示字符串一般用来输入多行文本,或者用于大段的注释
# 三双引号："""python"""，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象__doc__访问获得文档
# 区别:
# 若你的字符串里面本身包含单引号,必须用双引号
# 比如:"can't find the log\n"


# 五十九 Python的参数传递是值传递还是引用传递
# 举例说明Python函数参数传递的几种形式，并说明函数传参是值传递还是引用传递
# 1).Python的参数传递有：
# 位置参数
# 默认参数，
# 可变参数,
# 关键字参数
# 2).函数的传值到底是值传递还是引用传递，要分情况
# a.不可变参数用值传递：
# 像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象
# b.可变参数是用引用传递的
# 比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变

# 六十  什么是lambda函数？它有什么好处?