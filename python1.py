# 一.一行代码实现1--100之和
#利用sum()函数求和

# #方法1:
# print(sum(list(range(1,101))))

# #方法2:
# total = 0
# for i in range(1,101):
#     total += i
# print(total)


# 二. python2和python3的range（100）的区别

# python2返回列表，python3返回迭代器，节约内存



# 三. 列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]

# list1 = [1,2,3,4,5]
# def pingfang(x):
#     return x**2
# res = map(pingfang,list1)

# res = [i for i in res if i > 10]
# print(res)


# 四. python中生成随机整数、随机小数、0--1之间小数方法
# import random
# import numpy
# print(random.randint(1,10))

# print(numpy.random.randn(5))

# print(random.random())

# 16、<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的
# import re
# content = '<div class="nam">中国</div>'
# res = re.findall(r'<div class=".*">(.*)</div>',content)
# print(res)

# 五. python中断言方法举例

# assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错
# a = 3
# assert(a > 1)
# print('断言成功,程序向下执行')


# a = 4
# assert(a > 7)
# print('断言失败,程序报错')

# 六. 数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句
# select distinct name  from student

# 七. 10个Linux常用命令
#  ls cmd pwd cd ps kill grep awk find passwd vim cat touch rm less echo tree

# 八. python2和python3区别？列举5个

# 1、Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')

# Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'

# 2、python2 range(1,10)返回列表，python3中返回迭代器，节约内存

# 3、python2中使用ascii编码，python中使用utf-8编码

# 4、python2中unicode表示字符串序列，str表示字节序列

#       python3中str表示字符串序列，byte表示字节序列

# 5、python2中为正常显示中文，引入coding声明，python3中不需要

# 6、python2中是raw_input()函数，python3中是input()函数


# 九. 列出python中可变数据类型和不可变数据类型，并简述原理
# 不可变数据类型：数值型、字符串型string和元组tuple
# 可变数据类型：列表list和字典dict；

# 十. s = "ajldjlajfdljfddd"，去重并从小到大排序输出"adfjl"
# s =  "ajldjlajfdljfddd"
# s = set(s)
# s = list(s)
# s.sort(reverse=False)
# s = "".join(s)
# print(s)


# 十. 用lambda函数实现两个数相乘

# f = lambda x,y:x * y
# print(f(2,3))

# l1 = [1,2,3]
# m = map(lambda x:x**2,l1)
# print(list(m))

# 十一. 字典根据键从小到大排序

# dict={"name":"zs","age":18,"city":"深圳","tel":"1362626627"}
# list = sorted(dict.items(),key= lambda x: x[0])
# new_dict = {}
# for i in list:
#     new_dict[i[0]] = i[1]
# print(new_dict)

# 十二. 利用collections库的Counter方法统计字符串每个单词出现的次数"kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
# from collections import Counter
# s = "kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h"
# print(Counter(s))

# 十三. 字符串a = "not 404 found 张三 99 深圳"，每个词中间是空格，用正则过滤掉英文和数字，最终输出"张三  深圳"
# import re
# a = "not 404 found 张三 99 深圳"
# res = re.findall('[^(" ",a-z,A-Z,0-9)]+',a)
# print(" ".join(res))

# 十四. filter方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# def is_odd(x):
#     return x % 2 == 1

# f = filter(is_odd,a)
# print(list(f))

# 十五. 列表推导式求列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# res = [x for x in a if x % 2 ==1]
# print(res)

# 十六. 两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,5,6,7,8,9]
# x = [1,5,7,9]
# y = [2,2,6,8]
# x.extend(y)
# x.sort()
# print(x)

# 十七. log日志中，我们需要用时间戳记录error,warning等的发生时间，请用datetime模块打印当前时间戳 “2018-04-01 11:38:54”
# import datetime
# now = datetime.datetime.now()
# t = now.strftime('%Y-%m-%d %H:%M:%S')
# w = now.isoweekday()
# print('%s 星期: %s' % (t,w))

# 十八. 数据库优化查询方法

# 外键、索引、联合查询、选择特定字段等等


# 十九. 写一段自定义异常代码

# def fn():
#     try:
#         for i in range(1,10):
#             if i > 4:
#                 raise Exception("大于4了,坏了")
#             print(i)
#     except Exception as e:
#         print(e)

# fn()

# 二十. 正则表达式匹配中，（.*）和（.*?）匹配区别？

# （.*）是贪婪匹配，会把满足正则的尽可能多的往后匹配

# （.*?）是非贪婪匹配，会把满足正则的尽可能少匹配

# 二十一. 简述Django的orm

# ORM，全拼Object-Relation Mapping，意为对象-关系映射

# 实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可

# 二十二. [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]
# list1 = [[1,2],[3,4],[5,6]]
# res = [j for i in list1 for j in i]
# print(res)

# 二十三. x="abc",y="def",z=["d","e","f"],分别求出x.join(y)和x.join(z)返回的结果

# join()括号里面的是可迭代对象，x插入可迭代对象中间，形成字符串，结果一致，有没有突然感觉字符串的常见操作都不会玩了

# 顺便建议大家学下os.path.join()方法，拼接路径经常用到，也用到了join,和字符串操作中的join有什么区别，该问题大家可以查阅相关文档，后期会有答案

# 二十四. python中交换两个数值
# a,b = 3,4
# print(a,b)
# b,a = a,b
# print(a,b)

# 二十五. zip()函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。

# zip()参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不同时，zip能自动以最短序列长度为准进行截取，获得元组。
# x = [1,2,3]
# y = ["a","b","c"]
# z = zip(x,y)
# print(list(z))


# 二十六. a="张明 98分"，用re.sub，将98替换为100
# a="张明 98分"
# import re
# b = re.sub('[0-9]+','100',a)
# print(b)

# 二十七. 写5条常用sql语句

# show databases;

# show tables;

# desc 表名;

# select * from 表名;

# delete from 表名 where id=5;

# update students set gender=0,hometown="北京" where id=5

# 二十八. a="hello"和b="你好"编码成bytes类型
# a="hello"
# print(bytes(a,encoding="utf-8"))
# print(b'hello')
# b="你好"
# print(b.encode(encoding="utf-8"))

# 二十九.提高python运行效率的方法

# 1、使用生成器，因为可以节约大量内存

# 2、循环代码优化，避免过多重复代码的执行

# 3、核心模块用Cython  PyPy等，提高效率

# 4、多进程、多线程、协程

# 5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率


# 三十. 遇到bug如何处理

# 1、细节上的错误，通过print（）打印，能执行到print（）说明一般上面的代码没有问题，分段检测程序是否有问题，如果是js的话可以alert或console.log

# 2、如果涉及一些第三方框架，会去查官方文档或者一些技术博客。

# 3、对于bug的管理与归类总结，一般测试将测试出的bug用teambin等bug管理工具进行记录，然后我们会一条一条进行修改，修改的过程也是理解业务逻辑和提高自己编程逻辑缜密性的方法，我也都会收藏做一些笔记记录。

# 4、导包问题、城市定位多音字造成的显示错误问题.


# 三十一. 51、正则匹配，匹配日期2018-03-20
# import re
# url='https://sycm.taobao.com/bda/tradinganaly/overview/get_summary.json?dateRange=2018-03-20%7C2018-03-20&dateType=recent1&device=1&token=ff25b109b&_=1521595613462'
# res = re.findall(r'[0-9]{4}-[0-9]{2}-[0-9]{2}',url)
# print(res)

# 三十二. list=[2,3,5,4,9,6]，从小到大排序，不许用sort，输出[2,3,4,5,6,9]
# list=[2,3,5,4,9,6]
# res = sorted(list)
# print(res)


# 三十三. 53、写一个单例模式

# 因为创建对象时__new__方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个

# class Single(object):
#     __instance = None

#     def __init__(self,name,age):
#         self.name = name
#         self.age = age

#     def __new__(cls,name,age):
#         if not cls.__instance:
#             cls.__instance = object.__new__(cls)
#         return cls.__instance


# a = Single('han',20)
# b = Single('wang',30)

# print(id(a))
# print(id(b))

# 三十四 保留两位小数
# a = "%.03f"%1.33335
# print(a,type(a))

# b = round(float(a),2)
# print(b)

# 三十五  可变数据特性

# def fn(k,v,dic={}):
#     dic[k] = v
#     print(dic,id(dic))

# fn('one',1)
# fn('two',2)
# fn('ddd',3,{})

# 三十六. 分别从前端、后端、数据库阐述web项目的性能优化

# 该题目网上有很多方法，我不想截图网上的长串文字，看的头疼，按我自己的理解说几点

# 前端优化：

# 1、减少http请求、例如制作精灵图

# 2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差



# 后端优化：

# 1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。

# 2、异步方式，如果有耗时操作，可以采用异步，比如celery

# 3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况



# 数据库优化：

# 1、如有条件，数据可以存放于redis，读取速度快

# 2、建立索引、外键等


# 三十七.  python中copy和deepcopy区别
# 1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同。
# 2、复制的值是可变对象（列表和字典）

# 浅拷贝copy有两种情况：

# 第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。

# 第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。

# 深拷贝deepcopy：完全复制独立，包括内层列表和字典

# import copy
# list1 = [1,2,3,4]
# x = list1
# print(x,id(x))
# a = copy.copy(list1)
# b = copy.deepcopy(list1)
# print(list1,id(list1))
# print(a,id((a)))
# print(b,id(b))

# x[1] = 10
# print('x',x)
# print('a',a)
# print('b',b)
# print('list1',list1)

# import copy
# list1 = [1,2,[3,4]]
# x = list1
# print(x,id(x))
# a = copy.copy(list1)
# b = copy.deepcopy(list1)
# print(list1,id(list1))
# print(a,id((a)))
# print(b,id(b))

# x[1] = 10
# print('x',x)
# print('a',a)
# print('b',b)
# print('list1',list1)

# import copy
# list1 = [1,2,[3,4]]
# x = list1
# print(x,id(x))
# a = copy.copy(list1)
# b = copy.deepcopy(list1)
# print(list1,id(list1))
# print(a,id((a)))
# print(b,id(b))

# x[2][0] = 10
# print('list1',list1)
# print('x',x)
# print('a',a)
# print('b',b)

# 三十八  列表嵌套字典的排序，分别根据年龄和姓名排序

# foo = [{"name":"zs","age":19},{"name":"ll","age":54},{"name":"wa","age":17},{"name":"df","age":23}]
# res1 = sorted(foo,key=lambda x: x['name'])
# print(res1)

# res2 = sorted(foo,key=lambda x: x['age'],reverse=True)
# print(res2)


# view   77个


# 三十八. 根据键对字典排序（方法一，zip函数）
# dic = {'name':'zs',"sex":"man","city":"bj"}
# foo = zip(dic.keys(),dic.values())
# foo = list(foo)
# b = sorted(foo,key=lambda x: x[0])
# print('根据键排序',b)
# new_dic = {i[0]:i[1] for i in b}
# print("字典推导式构造字典",new_dic)

# 三十九. 根据键对字典排序（方法二,不用zip)
# 有没有发现dic.items和zip(dic.keys(),dic.values())都是为了构造列表嵌套字典的结构，方便后面用sorted()构造排序规则
# dic = {'name':'zs',"sex":"man","city":"bj"}
# b = sorted(dic.items(),key=lambda x: x[0])
# print('根据键排序',b)
# new_dic = {i[0]:i[1] for i in b}
# print("字典推导式构造字典",new_dic)


# 四十. 最后出一道检验题目，根据字符串长度排序，看排序是否灵活运用
# s = ["ab","abc","a","djdj"]
# # 不修改自身
# b = sorted(s, key=lambda x: len(x))
# print(b,s)

# # 修改自身
# s.sort(key=len)
# print(s)


# 四十一. s="info:xiaoZhang 33 shandong",用正则切分字符串输出['info', 'xiaoZhang', '33', 'shandong']
# import re
# s="info:xiaoZhang 33 shandong"
# # res = re.split('[: ]',s)
# res = re.split(':| ',s)
# print(res)


# 四十二. 正则匹配以163.com结尾的邮箱
# import re
# email_list = ['xiaowang@163.com','xiaowang@163.comhehe','.com.xiaowang.com']
# for email in email_list:
#     ret = re.match("[\w]{4,20}@163\.com$",email)
#     if ret:
#         print("%s 是符合规定的邮件地址,匹配的结果是: %s" % (email,ret.group()))
#     else:
#         print("%s 不符合要求" % email)

# 四十三 递归求和
# def get_sum(num):
#     if num >= 1:
#         res = num + get_sum(num - 1)
#     else:
#         res = 0
#     return res

# res = get_sum(10)
# print(res)


# 四十四. MyISAM 与 InnoDB 区别：

# 1、InnoDB 支持事务，MyISAM 不支持，这一点是非常之重要。事务是一种高

# 级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM

# 就不可以了；

# 2、MyISAM 适合查询以及插入为主的应用，InnoDB 适合频繁修改以及涉及到

# 安全性较高的应用；

# 3、InnoDB 支持外键，MyISAM 不支持；

# 4、对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM

# 表中可以和其他字段一起建立联合索引；

# 5、清空整个表时，InnoDB 是一行一行的删除，效率非常慢。MyISAM 则会重

# 建表；

# 四十五 正则匹配不是以4和7结尾的手机号
# import re
# tels = ["13100001234","18912344321","10086","18800007777"]
# for tel in tels:
#     ret = re.match('1\d{9}[1-3,5-6,8-9]',tel)
#     if ret:
#         print("想要的结果:",ret.group())
#     else:
#         print("不想要的结果:",tel)

# 四十六. 列举3条以上PEP8编码规范

# 1、顶级定义之间空两行，比如函数或者类定义。

# 2、方法定义、类定义与第一个方法之间，都应该空一行

# 3、三引号进行注释

# 4、使用Pycharm、Eclipse一般使用4个空格来缩进代码

# 四十七 正则匹配中文
# import re
# title = '你好,hello,世界'
# patt = re.compile(r'[\u4e00-\u9f5a]+')
# res = patt.findall(title)
# print(res)

# 四十八 生成0-100的随机数
# import random
# n1 = random.random() * 100
# print(n1)

# n2 = random.randint(1,100)
# print(n2)

# n3 = random.choice(range(1,101))
# print(n3)


# 四十八. 区分深拷贝和浅拷贝,赋值?
# 1、赋值：简单地拷贝对象的引用，两个对象的id相同。

# 2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。

# 3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。

# 浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。


# 四十九 闭包
# def num2(n):
#     i = 1
#     def num_in():
#         nonlocal i
#         i = i + n
#         print(i)
#     return num_in

# i = 0
# start = num2(3)
# while i<5:
#     start()
#     i += 1

# 五十 匿名函数
# from functools import reduce
# def num(x, y):
#     return x + y
# print(reduce(num, [1, 2, 3, 4]))

# res = reduce(lambda x,y: x + y,[1,2,3,4])
# print(res)

# print(list(filter(lambda x: x%2==0,range(10))))


# 五十一 多进程 多线程

# from multiprocessing import Process
# from threading import Thread
# import os,time
# def work():
#     res=0
#     for i in range(100000000):
#         res*=i

# if __name__ == "__main__":
#     l = []
#     start = time.time()
#     for i in range(4):
#         p = Process(target=work)
#         # p = Thread(target=work)
#         l.append(p)
#         p.start()
#     for p in l:
#         p.join()
#     stop = time.time()
#     print("run time is %s" % (stop-start))


# import threading
# import os
# from time import sleep

# def sorry(i):
#     sleep(5)
#     print('say sorry  {}'.format(i))


# if __name__ == '__main__':
#     for i in range(1,10):
#         t = threading.Thread(target=sorry, args=(i,))
#         t.start()


# 五十二 协程
# def custumer():
#     r = ''
#     while True:
#         n = yield r  # 接受send的值  返出yield的值
#         if not n:
#             return
#         print('custer {}'.format(n))
#         r = 'done'

# def produce(c):
#     c.__next__()
#     n = 0
#     while n < 5:
#         n += 1
#         print('produce {}'.format(n))
#         r = c.send(n)
#         print('custer return {}'.format(r))
#     c.close()

# c = custumer()
# produce(c)

 # 协程
# import gevent
# import time


# def foo():
#     print("running in foo")

#     gevent.sleep(2)

#     print("switch to foo again")


# def bar():
#     print("switch to bar")

#     gevent.sleep(5)

#     print("switch to bar again")


# start = time.time()

# gevent.joinall(

#     [gevent.spawn(foo),

#      gevent.spawn(bar)]

# )

# print(time.time() - start)

# 五十三 Fibonacci数列
# def  fab(n):
#     a, b = 0, 1
#     while n:
#         yield b
#         a, b = b,a+b
#         n -= 1

# print(list(fab(10)))


# def fab(n):
#     if n > 2:
#         res = fab(n-1) + fab(n-2)
#     else:
#         res = 1
#     return res

# l = []
# for i in range(1, 11):
#     l.append(fab(i))
# print(l)

# 五十四  函数赋值   难点
# 函数中 默认参数为可变数据时， 只初始化一次
# def f(x, l=[]):
#     for i in range(x):
#         l.append(i*i)
#     print(l)

# f(2) # [0, 1]
# f(3,[3,2,1]) # [3, 2, 1, 0, 1, 4]  # 自己单独开辟
# f(3) # [0, 1, 0, 1, 4]  # 和f(2)共用

#  设计模式
#  五十五 单例

# 单例---类方法方式

# class Single():
#     def __init__(self, name):
#         self.name = name
#     @classmethod
#     def instance(cls, *args, **kwargs):
#         if not hasattr(Single, "_instance"):
#             Single._instance = Single(*args, **kwargs)
#         return Single._instance
# s1 = Single.instance('Gage')
# s2 = Single.instance()
# print(s1)
# print(s2)
# 单例---new方式
# class Single(object):
#     __isstance = None
#     __first_init = False
#     def __new__(cls, *args, **kwargs):
#         if not cls.__isstance:
#             cls.__isstance = object.__new__(cls)
#         return cls.__isstance
#     def __init__(self, name):
#         if not self.__first_init:
#             self.name = name
#             Singleton.__first_init = True
# a = Single('a')
# b = Single('b')
# print(id(a))
# print(id(b))


# 五十六 工厂模式
# # 首先定义一个抽象基类
# class CarStore(object):

#     # 定义生产汽车的方法
#     def createcar(self, name):
#         pass

#     # 根据类型去生产车
#     def order(self, name):
#         self.car = self.createcar(name)
#         self.car.move()


# # 定义4s店  实现抽象类
# class AoDiCarStore(CarStore):

#     def createcar(self, name):
#         self.factory = CarFactory()
#         return self.factory.createcar(name)


# # 创建一个车
# class AoDi():
#     def move(self):
#         print('移动')
# # 定义一个工厂
# class CarFactory():
#     def createcar(self, name):
#         self.name = name
#         if self.name == 'AoDi':
#             self.car = AoDi()
#         return self.car
# aodi = AoDiCarStore()
# aodi.order('AoDi')


# 五十七  二分法
# mylist = [1,3,5,7,9]  找到3

# def search(mylist,item):
#     low = 0
#     high = len(mylist) -1
#     while True:
#         mid = (low + high) //2
#         if mylist[mid] > item:
#             high = mid - 1
#         elif mylist[mid] < item:
#             low = mid + 1
#         else:
#             return mid


# mylist = [1,3,5,7,9]
# res = search(mylist,9)
# print(res)

# 五十八 单引号，双引号，三引号的区别
# 分别阐述3种引号用的场景和区别
# 1),单引号和双引号主要用来表示字符串
# 比如:
# 单引号:'python'
# 双引号:"python"
# 2).三引号
# 三单引号:'''python ''',也可以表示字符串一般用来输入多行文本,或者用于大段的注释
# 三双引号："""python"""，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象__doc__访问获得文档
# 区别:
# 若你的字符串里面本身包含单引号,必须用双引号
# 比如:"can't find the log\n"


# 五十九 Python的参数传递是值传递还是引用传递
# 举例说明Python函数参数传递的几种形式，并说明函数传参是值传递还是引用传递
# 1).Python的参数传递有：
# 位置参数
# 默认参数，
# 可变参数,
# 关键字参数
# 2).函数的传值到底是值传递还是引用传递，要分情况
# a.不可变参数用值传递：
# 像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象
# b.可变参数是用引用传递的
# 比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变

# 六十  写一个函数, 输入一个字符串, 返回倒序排列的结果
# 输入: string_reverse(‘abcdef’), 返回: ‘fedcba’,写出你能想到的多种方法

# 方法一:
# def string_reverse(str1):
#     str1_list = list(str1)
#     str1_list.reverse()
#     res = ''.join(str1_list)
#     return res

# aaa = 'abcdef'
# res = string_reverse(aaa)
# print(res)

# 方法二:
# def string_reverse1(text='abcdef'):
#     return text[::-1]

# 六十一: 按升序合并如下两个list, 并去除重复的元素

# list1 = [2, 3, 8, 4, 9, 5, 6]
# list2 = [5, 6, 10, 17, 11, 2]

# list1.extend(list2)
# list1.sort()
# s = set(list1)
# list1 = list(s)
# print(list1)

# 更简洁
# list3=list1+list2
# print sorted(list(set(list3)))


# 六十二 以下的代码的输出将是什么? 说出你的答案并解释
# class Parent(object):
#     x = 1
# class Child1(Parent):
#     pass
# class Child2(Parent):
#     pass

# print Parent.x, Child1.x, Child2.x
# Child1.x = 2
# print Parent.x, Child1.x, Child2.x
# Parent.x = 3
# print Parent.x, Child1.x, Child2.x

# 1 1 1
# 1 2 1
# 3 2 3

# 六十三 下面的代码会不会报错
# list = ['a', 'b', 'c', 'd', 'e']
# print list[10:]
# 　　

# 不会报错，而且会输出一个 []，并且不会导致一个 IndexError

# 解答:

# 当试图访问一个超过列表索引值的成员将导致 IndexError（比如访问以上列表的 list[10]）。
# 尽管如此，试图访问一个列表的以超出列表长度数作为开始索引的切片将不会导致 IndexError，
# 并且将仅仅返回一个空列表
# 一个讨厌的小问题是它会导致出现 bug ，并且这个问题是难以追踪的，
# 因为它在运行时不会引发错误，吐血啊~~


# 六十三  说出下面list1,list2,list3的输出值
# def extendList(val, list=[]):
#     list.append(val)
#     return list
# list1 = extendList(10)
# list2 = extendList(123,[])
# list3 = extendList('a')
# print "list1 = %s" % list1
# print "list2 = %s" % list2
# print "list3 = %s" % list3
# >>
# list1 = [10, 'a']
# list2 = [123]
# list3 = [10, 'a']

# 　许多人会错误的认为 list1 应该等于 [10] 以及 list3 应该等于 ['a']。认为 list 的参数会在 extendList 每次被调用的时候会被设置成它的默认值 []。

# 　　尽管如此，实际发生的事情是，新的默认列表仅仅只在函数被定义时创建一次。随后当 extendList 没有被指定的列表参数调用的时候，其使用的是同一个列表。这就是为什么当函数被定义的时候，表达式是用默认参数被计算，而不是它被调用的时候。

# 　　因此，list1 和 list3 是操作的相同的列表。而list2是操作的它创建的独立的列表（通过传递它自己的空列表作为list参数的值）

# 　　所以这一点一定要切记切记.下面我们把list置为None就可以避免一些麻烦了

# def extendList(val, list=None):
#         if list is None:
#             list = []
#         list.append(val)
#         return list

# list1 = extendList(10)
# list2 = extendList(123,[])
# list3 = extendList('a')
# print("list1 = %s" % list1)
# print("list2 = %s" % list2)
# print("list3 = %s" % list3)

# 六十四 写出一段python 代码实现一个删除一个list 里面重复元素。
# list_element = ['a','c,','z','x','a']      #此列表元素有重复
# delete_element = list( set(list_element))     #利用集合的唯一性删除重复元素
# delete_element.sort(key = list_element.index)   #对修改后的列表进行排序
# print("原始列表为：",list_element)
# print("修改后的列表为：",delete_element)


# 六十五 反斜杠的困扰
# 　　与大多数编程语言相同，正则表达式里面使用“ \ ”作为转义字符，这就可能造成反斜杠困扰
# ，假如你需要匹配文本中的字符'' \ '' 那么使用编程语言表示的正则表达式里面将需要4个反斜
# 杠"\\\\",前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表
# 达式里面转义成一个反斜杠，python里的原生字符串很好的解决了这个问题，这个例子中的正则
# 表达式可以使用  r"\\  表示。同样，匹配一个数字的"\\d"可以写成r"\d.有了原生字符串，你再
# 也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。


# 六十六 reduce（假设面试官让你把number =[2, -5, 9, -7, 2, 5, 4, -1, 0, -3, 8]中的正数的平均值求出来，你怎么算）

#计算数组中正整数的平均值

# 方法1:
# number =[2, -5, 9, -7, 2, 5, 4, -1, 0, -3, 8]
# count = 0
# sum = 0

# for i in range(len(number)):
#     if number[i]>0:
#         count += 1
#         sum += number[i]

# print sum,count

# if count>0:
#     average = sum/count

# print average

# #========输出===========
# 30 6
# 5

# 还有一种方法：

# number =[2, -5, 9, -7, 2, 5, 4, -1, 0, -3, 8]

# positive = filter(lambda x: x>0, number)

# average = reduce(lambda x,y: x+y, positive)/len(positive)

# print average

# #========输出===========
# 5

# 这段代码最终达到的目的同样是求取正数平均值，但是它得到结果的方式和 之前有着本质的差别：通过描述一个列表->正数平均值 的映射，而不是描述“从列表得到正数平均值应该怎样做”来达到目的。

# 六十七 pep规范
# 每一级缩进使用4个空格
# 所有行限制的最大字符数为79。

# 顶层函数和类的定义，前后用两个空行隔开。
# 类里的方法定义用一个空行隔开。
# 相关的功能组可以用额外的空行（谨慎使用）隔开。一堆相关的单行代码之间的空白行可以省略（例如，一组虚拟实现 dummy implementations）。
# 在函数中使用空行来区分逻辑段（谨慎使用）。

# 导入通常在分开的行

# 六十八  列举 Python2和Python3的区别？

# Python2默认的字符编码是ASCII，默认的文件编码也是ASCII
# python3默认的字符编码是unicode，默认的文件编码是utf-8。

# 在python2里，将string处理为原生的bytes类型。
# python3把字符串的编码改成了unicode, 还把str和bytes做了明确区分， str就是unicode格式的字符，bytes是单纯二进制。

# print语句没有了，取而代之的是print()函数。

# 在python 2.x中/除法整数相除的结果是一个整数，把小数部分完全忽略掉，浮点数除法会保留小数点的部分得到一个浮点数的结果。
# 在python 3.x中/除法不再这么做了，对于整数之间的相除，结果也会是浮点数。

# 捕获异常的语法由 except exc, var 改为 except exc as var。

# Python 2.x 中反引号``相当于repr函数的作用
# Python 3.x 中去掉了``这种写法，只允许使用repr函数

# Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long

# 在 Python 2 中 有range()和xrange() ，一般使用xrange()创建迭代对象。
# 在 Python 3 中，range() 是像 xrange()那样实现，xrange()内置函数已经删除。

# 六十九  简述Python的深浅拷贝以及应用场景？

# 导入模块：import copy
# 浅拷贝：copy.copy
# 深拷贝：copy.deepcopy
#     浅拷贝指仅仅拷贝数据集合的第一层数据，深拷贝指拷贝数据集合的所有层。<br>　　 所以对于只有一层的数据集合来说深浅拷贝的意义是一样的，比如字符串，数字，还有仅仅一层的字典、列表、元祖等.

# 应用：
# 　　浅拷贝在拷贝大量数据且不需要改变内部元素的值的时候，能大量的减少内存的使用；
# 　　深拷贝在拷贝大量数据的时候，需要在前后内部元素的内容进行改变的时候，可以修改拷贝出来的模板


# 七十  Python垃圾回收机制？

# 1、回收计数引用为0的对象，释放其占用空间
# 2、循环垃圾回收器。释放循环引用对象

# 七十一 至少列举8个常用模块都有那些？

# 1、sys:用于提供对解释器相关的访问以及维护，并有很强的交互功能
# 2、time： 时间模块
# 3、os：用于提供操作系统模块
# 4、ashlib：用于加密相关的操作
# 5、random：生成随机变量
# 6、pickle：用于python特有的类和pthon的数据类型间进行转换
# 7、datetime：date和time的结合体
# 8、re：正则表达式模块

# 七十二 re的match和search区别？

# re.match 从头开始匹配
# re.search 匹配包含

# match与search函数功能一样，match匹配字符串开始的第一个位置，search是在字符串全局匹配第一个符合规则的。

# 七十三 如何实现[‘1’,’2’,’3’]变成[1,2,3] ?

# li = ['1','2','3']

# # 方法一：
# new_li = [int(x) for x in li]
# print(new_li)  # [1, 2, 3]

# # 方法二：
# new_li2 = list(map(lambda x:int(x), li))
# print(new_li2)   # [1, 2, 3]


# 七十四 请用代码简单实现stack(栈)。

# class Stack:
#     """栈：先进后出"""
#     def __init__(self):
#         self.stack = []

#     def push(self, element):
#         """进栈"""
#         self.stack.append(element)

#     def pop(self):
#         """出栈"""
#         if len(self.stack) > 0:
#             return self.stack.pop()
#         else:
#             print("栈已经空了")

#     def get_top(self):
#         """取栈顶"""
#         if len(self.stack) > 0:  # 判断栈是否为空
#             return self.stack[-1]
#         else:
#             return None

# 七十五 常用字符串格式化哪几种？

# %格式化字符串操作符
# print 'hello %s and %s' % ('df', 'another df')

# 字典形式的字符串格式化方法
# print 'hello %(first)s and %(second)s' % {'first': 'df', 'second': 'another df'}

# 字符串格式化（format）：
# 1、使用位置参数
#     位置参数不受顺序约束，且可以为{}，参数索引从0开始，format里填写{}对应的参数值。
# >>> msg = "my name is {}, and age is {}"
# >>> msg.format("hqs",22)
# 'my name is hqs, and age is 22'

# 2、使用关键字参数
#     关键字参数值要对得上，可用字典当关键字参数传入值，字典前加**即可
# >>> hash = {'name':'john' , 'age': 23}
# >>> msg = 'my name is {name}, and age is {age}'
# >>> msg.format(**hash)
# 'my name is john,and age is 23'

# 3、填充与格式化
#     :[填充字符][对齐方式 <^>][宽度]
# >>> '{:*<10}'.format(10)      # 左对齐
# '10********'


# 七十六 简述 生成器、迭代器、可迭代对象 以及应用场景？

# 生成器(generator)：列表元素可以按照某种算法推算出来（有规律的数组），则可以在循环的过程中不断推算出后续的元素。这种方式就不必创建完整的list，可以节省大量的空间。python中，这种一边循环一边计算的机制，称为生成器：generator。

# 迭代器(Iterator)：可以被next()函数调用并不断返回下一个值得对象称为迭代器(Iterator)。

# 可迭代对象(Iterable)：可以直接作用于for循环的对象（其中包含集合数据类型：list\tuple\dict\set\str；还包含生成器表达式和生成器函数）。可以使用isinstance()判断一个对象是否是Iterable对象。


# 七十七 谈谈你对闭包的理解？

# 在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。

# 通俗易懂的说法：当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。
# 闭包存在的意义：它夹带了外部变量（私货）。同一个的函数夹带了不同的私货，就实现了不同的功能。

# 七十八如何生成一个随机数？

# random模块可以很容易生成随机数和随机字符串。

# random.randint(1, 100)  # 1-100之间取一个随机数
# random.randrange(1, 100)  # 1-100之间取一个随机数
# randint&randrange区别：randint包含100，randrange不包含100!!!


# string模块可以生成随机字符串

# string.digits  # 数字字符串   '0123456789'
# string.ascii_letters  # 字母字符串 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
# string.ascii_lowercase  # 小写字母字符串  'abcdefghijklmnopqrstuvwxyz'
# string.ascii_uppercase   # 大写字母字符串 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# string.punctuation   # 特殊字符  '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

# import random
# import string
# ran_str = ''.join(random.sample(string.ascii_lowercase+string.digits,8))
# print(ran_str)

# 七十八 谈谈你对面向对象的理解？

# OOP(Object Oriented Programing）编程是利用“类”和“对象”来创建各种模型来实现对真实世界的描述。与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界而非流程的模拟，是一种“上帝式”的思维方式。

# 核心就是对象二字，对象就是特征与技能的结合体。

# 优点：
#     1、使程序更加容易扩展和易更改，使开发效率变得更高(对某个对象类属性的修改，会立刻反映到整个体系中)
#     2、基于面向对象的程序可以使他人更加容易理解代码逻辑。

# 缺点：
#     编程复杂度高、可控性差（无法像面向过程程序那样精准预测问题处理过程与结果，对象之间的交互，比较难预测最终的结果）

# 适用场景：
#     应用于需求经常变化的软件中，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。

# 七十九 面向对象中super的作用？
# super() 函数是用于调用父类(超类)的一个方法。
# 　　super 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。
# 　　MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。

# 作用：
# 1、根据 mro 的顺序执行方法
# 2、主动执行Base类的方法

# 八十 列举面向对象中带双下划线的特殊方法，如：__new__、__init__

# __dict__：查出一个字典，所有实例共享的变量和函数，dir()的子集
# __name__：查看类的名字（这里的类名是字符串类型的）
# __doc__：显示注释
# __module__：类定义所在的模块

# __init__：为对象定制自己独有的特征
# __base__：只查看从左到右继承的第一个子类
# __bases__：查看所有继承的父类

# __get__():调用一个属性时,触发
# __set__():为一个属性赋值时,触发
# __delete__():采用del删除属性时,触发

# __getitem__(self,key):返回键对应的值
# __setitem__(self,key,value)：设置给定键的值
# __delitem__(self,key):删除给定键对应的元素

# __str__,__repr__:改变对象的字符串显示
# __format__：自定制格式化字符串<br>__call__：方法由对象后加括号触发，即：对象() 或者 类()()

# 八十一 静态方法和类方法区别？

# 绑定方法：绑定给谁，就应该由谁来调用，谁来调用就会把调用者当作第一个参数自动传入

# 绑定到对象的方法：在类内定义的没有被任何装饰器修饰的，自动将对象当做第一个参数传入（属于类的函数，类可以调用，但是必须按照函数的规则来，没有自动传值那么一说）

# 绑定到类的方法：在类内定义的被装饰器@classmethod修饰的方法。自动将类当做第一个参数传入（其实对象也可以调用，但仍将类作为第一个参数传入）

# 非绑定方法：在类中用@staticmethod装饰器装饰的方法。不与类或对象绑定，类和对象都可以调用，但是没有自动传值那么一说。

# 八十二 列举面向对象中的特殊成员以及应用场景

# 1. __doc__ #输出：类的描述信息

# 2. __module__ 和 __class__
# 　　__module__ 表示当前操作的对象在那个模块
# 　　__class__ 表示当前操作的对象的类是什么

# 3. __init__
# 　　构造方法，通过类创建对象时，自动触发执行。

# 4. __del__
# 　　析构方法，当对象在内存中被释放时，自动触发执行。

# 5. __call__
# 　　对象后面加括号，触发执行。即： 对象() 或 类()()

# class Foo:
#     def __init__(self):
#         pass

#     def __call__(self, *args, **kwargs):
#         print('__call__')


# obj = Foo()  # 执行 __init__
# obj()  # 执行 __call__

# 6. __dict__ 类或对象中的所有成员

# 7. __str__
# 　　如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。

# 8. __getitem__ __setitem__ __delitem__
# 　　类似字典一样索引的操作，以上分别表示获取，设置，删除。（当在类外面做了这些操作后触发这些函数，甚至可删除不存在的数据）

# class Foo(object):
#     def __getitem__(self, key):
#         print('__getitem__',key)
#     def __setitem__(self, key, value):
#         print('__setitem__',key,value)
#     def __delitem__(self, key):
#         print('__delitem__',key)

# obj = Foo()

# result = obj["k1"]          # 自动触发执行 __getitem__
# obj['k2'] = 'wupeiqi'      # 自动触发执行 __setitem__
# del obj['k1']              # 自动触发执行 __delitem__

# __getitem__ k1
# __setitem__ k2 wupeiqi
# __delitem__ k1

# 9. __new__ 用来将类实例化的

# def __new__(cls,*args,**kwargs):   #重构__new__方法：在实例化之前做些事情
#     print("Foo --new--")
#     return object.__new__(cls)     #继承父类的__new__方法（此时cls是一个对象）


# 八十三  什么是反射？以及应用场景？

# 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。
# python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射）

# 四个实现反射的函数：
# hasattr(object,name)   # 判断object中有没有一个name字符串对应的方法或属性
# getattr(object, name, default=None)   # 获取属性
# setattr(x, y, v)   # 设置属性
# delattr(x, y)   # 删除属性
# 　　实现可插拔机制，常用于web框架的CBV配置文件获取类。

# 八十四 metaclass作用？以及应用场景？***

# 元类是类的类，是类的模板。
# 元类作用：是控制如何创建类的，正如类是创建对象的模板一样，而元类的主要目的是为了控制类的创建行为。


 # 八十五 用尽量多的方法实现单例模式。

# # 单例：即单个实例，指的是同一个类实例化多次的结果指向同一个对象，用于节省内存空间
# # 如果我们从配置文件中读取配置来进行实例化，在配置相同的情况下，就没必要重复产生对象浪费内存了
# #settings.py文件内容如下
# HOST='1.1.1.1'
# PORT=3306

# #方式一:定义一个类方法实现单例模式
# import settings

# class Mysql:
#     __instance=None
#     def __init__(self,host,port):
#         self.host=host
#         self.port=port

#     @classmethod
#     def singleton(cls):
#         if not cls.__instance:
#             cls.__instance=cls(settings.HOST,settings.PORT)
#         return cls.__instance


# obj1=Mysql('1.1.1.2',3306)
# obj2=Mysql('1.1.1.3',3307)
# print(obj1 is obj2) #False

# obj3=Mysql.singleton()
# obj4=Mysql.singleton()
# print(obj3 is obj4) #True



# #方式二：定制元类实现单例模式
# import settings

# class Mymeta(type):
#     def __init__(self,name,bases,dic): #定义类Mysql时就触发

#         # 事先先从配置文件中取配置来造一个Mysql的实例出来
#         self.__instance = object.__new__(self)  # 产生对象
#         self.__init__(self.__instance, settings.HOST, settings.PORT)  # 初始化对象
#         # 上述两步可以合成下面一步
#         # self.__instance=super().__call__(*args,**kwargs)


#         super().__init__(name,bases,dic)

#     def __call__(self, *args, **kwargs): #Mysql(...)时触发
#         if args or kwargs: # args或kwargs内有值
#             obj=object.__new__(self)
#             self.__init__(obj,*args,**kwargs)
#             return obj

#         return self.__instance




# class Mysql(metaclass=Mymeta):
#     def __init__(self,host,port):
#         self.host=host
#         self.port=port



# obj1=Mysql() # 没有传值则默认从配置文件中读配置来实例化，所有的实例应该指向一个内存地址
# obj2=Mysql()
# obj3=Mysql()

# print(obj1 is obj2 is obj3)

# obj4=Mysql('1.1.1.4',3307)



# #方式三:定义一个装饰器实现单例模式
# import settings

# def singleton(cls): #cls=Mysql
#     _instance=cls(settings.HOST,settings.PORT)

#     def wrapper(*args,**kwargs):
#         if args or kwargs:
#             obj=cls(*args,**kwargs)
#             return obj
#         return _instance

#     return wrapper


# @singleton # Mysql=singleton(Mysql)
# class Mysql:
#     def __init__(self,host,port):
#         self.host=host
#         self.port=port

# obj1=Mysql()
# obj2=Mysql()
# obj3=Mysql()
# print(obj1 is obj2 is obj3) #True

# obj4=Mysql('1.1.1.3',3307)
# obj5=Mysql('1.1.1.4',3308)
# print(obj3 is obj4) #False

# 八十六  装饰器的写法以及应用场景。
# import datetime

# def log(func):   # 装饰器接受一个函数作为参数，并返回一个函数
#     def wrapper(*args, **kw):
#         print('call %s(): ' % func.__name__)
#         return func(*args, **kw)
#     return wrapper

# @log  # 运用@语法把装饰器放置在函数定义处
# def now():
#     print(datetime.datetime.now())

# now()
# """
# call now():
# 2018-03-20 23:00:05.201096
# """

# # 应用场景：Django的csrf，缓存，登录认证，Falsk中的许多装饰器

# 八十七 json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？

# json只能支持int\str\list\tuple\dict

# import json, datetime
# from json import JSONEncoder

# class ComplexEncoder(JSONEncoder):
#     def default(self, obj):
#         if isinstance(obj, datetime.datetime):
#             return obj.strftime('%Y-%m-%d %H:%M:%S')
#         else:
#             return super(ComplexEncoder, self).default(obj)

# d = {'name': 'alex', 'data': datetime.datetime.now()}
# print(json.dumps(d, cls=ComplexEncoder))
# # {"name": "alex", "data": "2018-09-28 14:49:42"}


# 八十八 json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？
# import json

# a = json.dumps({"ddf": "你好"}, ensure_ascii=False)
# print(a)
# # {"ddf": "你好"}

# 八十九  什么是断言？应用场景？
# assert断言——声明其布尔值必须为真判定，发生异常则为假。

# info = {}
# info['name'] = 'egon'
# info['age'] = 18

# # if 'name' not in info:
# #     raise KeyError('必须有name这个key')
# #
# # if 'age' not in info:
# #     raise KeyError('必须有age这个key')

# # 用assert取代上述代码：
# assert ('name' in info) and ('age' in info)

# 设置一个断言目的就是要求必须实现某个条件。


# 九十 有用过with statement吗？它的好处是什么？

# with语句的作用是通过某种方式简化异常处理，它是所谓的上下文管理器的一种

# 用法举例如下：

#  with open('output.txt', 'w') as f:
#         f.write('Hi there!')

#     当你要成对执行两个相关的操作的时候，这样就很方便，以上便是经典例子，with语句会在嵌套的代码执行之后，自动关闭文件。<br><br>这种做法的还有另一个优势就是，无论嵌套的代码是以何种方式结束的，它都关闭文件。<br>　　如果在嵌套的代码中发生异常，它能够在外部exception handler catch异常前关闭文件。<br>　　如果嵌套代码有return/continue/break语句，它同样能够关闭文件。

# 九十一 使用代码实现查看列举目录下的所有文件。

# import os

# BASE_DIR = os.path.dirname(os.path.abspath(__file__))
# print(BASE_DIR)
# print(os.listdir(BASE_DIR))
# """
# /Users/hqs/PycharmProjects/日常练习
# ['字符串倒序.py', '学生类统计实例化个数.py', '类计算器.py', '生成器日志调用.py', 'lamba_test.py']
# """


# 九十二 简述 yield和yield from关键字。

# 当一个函数中出现yield关键字的时候，那么这个函数就是一个生成器(generator)。
# 函数转化为generator后，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

# yield from iterable就是for item in iterable: yield item的语法糖。
# 注意yield from 后面一定是可迭代对象(iterable)。



# 九十三  删除包含特定值的所有列表元素

# 使用函数remove()来删除列表中的特定值，因为函数remove()删除特定值。如果列表包含了多个相同条件的特定值，可以使用while循环进行逐一删除。

# pets = ['dog','cat','dog','goldfish','cat','rabbit','cat']
# print(pets)

# while 'cat' in pets:
#     pets.remove('cat')

# print(pets)
# 打印结果

# ['dog','cat','dog','goldfish','cat','rabbit','cat']
# ['dog','dog','goldfish','rabbit']


# 九十三 re模块
# import re
# str1 = "Python's features"
# str2 = re.match( r'(.*)on(.*?) (.*)', str1, re.M|re.I)
# print(str2.group())
# print(str2.group(1))
# print(str2.group(2))
# print(str2.group(3))


# 九十四  有一段英文文本，其中有单词连续重复了2次，编写程序检查重复的单词并只保留一个。例如文本内容为“This is is a desk.”，程序输出为“This is a desk.”
# a = input("输入").split()
# b = list()
# for i in a:
#     if i not in b:
#         b.append(i)
# print(" ".join(b))


# 九十五 编写程序，用户输入一个目录和一个文件名，搜索该目录及其子目录中是否存在该文件。

# import os

# "D:\developer\qiubai.txt"
# def test():
#     # 用户传入的路径和文件名
#     file_path = "D:\developer\qiuai.txt"
#     # file_path = "D:\developer\python_spider\qiubai\qiubai.txt"
#     # 取文件名
#     file_name = file_path.split("\\")[-1]
#     # 取路径
#     file_list = file_path.split("\\")[:-1]
#     file_path = "\\".join(file_list)
#     # 判断是否存在文件
#     for root,dirs,files in os.walk(file_path):
#         if file_name in files:
#             print(root)
#             print("YES")
#             break
#     else:
#         print("NO")

# if __name__ == '__main__':
#     test()

# 九十六 编写程序，生成一个包含50个随机整数的列表，然后删除其中所有奇数。（提示：从后向前删。）

# import random
# list = [random.randint(0,100) for i in range(50)]
# print(list)
# for i in range(49,-1,-1):
#     if list[i]%2 ==1:
#         del list[i]
# print([list])

# 九十七 编写代码，将当前工作目录修改为“c:\”，并验证，最后将当前工作目录恢复为原来的目录。
# import os
# cwd = os.getcwd()
# os.chdir("C:\\")
# os.chdir(cwd)

# 九十八 编写程序，生成包含1000个0到100之间的随机整数，并统计每个元素的出现次数。（提示：使用集合。）
# 方法1：Counter模块

# from collections import Counter
# import random
# list1 = [random.randint(0,100) for i in range(1000)]
# Counter(list1)
# # 方法2： 集合set()

# import random
# list1 = [random.randint(0,100) for i in range(1000)]
# list2 = dict([(i,list1.count(i)) for i in set(list1)])


# import random
# list1= [ random.randrange(0,100) for i in range(1000)]
# dict1 = {}
# for i in set(list1):
#     dict1[i] = list1.count(i)
# print(dict1)

# 九十九 编写程序，用户输入一个列表和2个整数作为下标，然后输出列表中介于2个下标之间的元素组成的子列表。例如用户输入[1,2,3,4,5,6]和2,5，程序输出[3,4,5,6]。

# def sub_list(l,num1,num2):
#     return l[num1:num2+1]

# res = sub_list([1,2,3,4,5,6],2,5)
# print(res)



# 一百: 假设有列表a = ['name','age','sex']和b = ['Dong',38,'Male']，请使用一个语句将这两个列表的内容转换为字典，并且以列表a中的元素为键，以列表b中的元素为值，这个语句可以写为

# a = ['name','age','sex']
# b = ['Dong',38,'Male']
# dict1= dict(zip(a,b))
# print(dict1)

# {a[i]:b[i] for i in range(len(a))}


# 一百零一 编写程序，将包含学生成绩的字典保存为二进制文件，然后再读取内容并显示。

# import pickle

#    def main():
#        dic = {"li": 29, "wu":30, "zhao":30, "qian":50, "sun": 90}
#        with open('dict.dat','wb') as f:
#            pickle.dump(dic,f)
#        f = open('dict.dat', 'rb')
#        print(pickle.load(f))
#        f.close()

#   if __name__ == "__main__":
#       main()


# 一百零二  编写程序，生成一个包含20个随机整数的列表，然后对其中偶数下标的元素进行降序排列，奇数下标的元素不变。（提示：使用切片。）

# import random
# x = [random.randint(0,100) for i in range(20)]
# print(x)
# y = x[::2]
# y.sort(reverse=True)
# x[::2] = y
# print(x)

# 一百零三 编写程序，生成包含20个随机数的列表，然后将前10个元素升序排列，后10个元素降序排列，并输出结果。

# import random
# x = [random.randint(0,100) for i in range(20)]
# print(x)
# y = x[0:10]
# y.sort()
# x[0:10] = y
# y = x[10:20]
# y.sort(reverse=True)
# x[10:20] = y
# print(x)

# import random
# rand = [random.randint(1,40) for i in range(20)]
# print(rand)
# for i in range(0,10):
#     for j in range(i+1,10):
#         if rand[i] > rand[j]:
#             rand[i],rand[j] = rand[j],rand[i]
# for i in range(10,20):
#     for j in range(i+1,20):
#         if rand[i] < rand[j]:
#             rand[i],rand[j] = rand[j],rand[i]

# print(rand)

# 一百零四 